# CHAPTER 05_변경에 강하게 설계한다: MVVM 설계 기법의 이해와 라이브러리 활용

액티비티 클래스 : 하나의 화면을 대표하는 클래스

- 화면을 표현하기 위한 비즈니스 로직
- View 이벤트 수신
- View에 데이터를 반영

-> 많은 처리 내용을 기술하게 되고, 결국에는 변경에 취약하고 관리하기 힘든 `스파게티 코드`가 되기 십상  

<br/>

MVP(Model View Presenter) : 역할에 따라 코드를 분리할 수 있어 `변경에 강한 코드` 기술 가능

MVVM(Model View ViewModel) : `Data Binding`을 전제로 한 설계 기법

<br/>

------

<br/>

## MVP (Model View Presenter)

#### 구조

- Model
  - 데이터, 비즈니스 로직
  - UI에 관한 로직은 가지지 않음
  - 데이터베이스나 API 접근에 관한 처리
- View
  - 데이터를 표시
  - 액션은 뷰에서 처리하지 않고 프레젠터에 위임
- Presenter
  - 모델과 뷰 사이에서 서로 통신
  - 뷰에서 발생한 이벤트가 프레젠터에 알려지면 프레젠터는 그 이벤트에 대응하는 처리를 함
  - 뷰와 모델 사이에는 항상 프레젠터가 들어감



#### 장점

- 어느 처리 내용이 어디에 있는지 명확
- 코드의 관리 효율 향상
- 액티비티를 작게 만들 수 있음
- 뷰와 모델의 의존관계가 없어짐



#### 단점

- 프레젠터의 인터페이스 부분이 길어지기 쉬움
- 모델에서 가져온 데이터를 뷰에 표시하는 것을 개발자가 직접 구현해야 함
- UI 로직을 프레젠터로 분리하는 설계의 난이도가 높음

<br/>

<br/>

## MVVM (Model View ViewModel)

#### Data Binding

- 사용자 인터페이스와 데이터를 연결(바인딩)하는 메커니즘



#### 구조

- Model
  - 데이터, 비즈니스 로직
- View
  - 데이터 표시
  - ViewModel이 모델에서 가져온 데이터를 반영해서 표시
  - 데이터 바인딩을 통해 자동으로 뷰에 반영되므로 뷰 부분에서 반영을 구현 할 필요가 없음
  - 애니메이션, 액티비티 전환 등은 뷰에서 구현
- ViewModel
  - 뷰의 상태, UI에 관한 로직 구현
  - 데이터 바인딩을 통해 ViewModel의 상태가 뷰에 반영
  - 이벤트를 ViewModel이 받고 모델과 데이터를 주고받아 데이터 바인딩으로 뷰의 상태 갱신



#### 장점

- 액티비티 작게 만들 수 있음
- MVP와 비교할 때 데이터 바인딩으로 인해 모델의 데이터를 뷰에 반영하는 로직의 작성이 불필요하므로 해당 코드를 줄일 수 있음
- 테스트하기 쉬움



#### 단점

- 데이터 바인딩 처리는 블랙박스화되어 가독성이 낮고 디버그가 어려움